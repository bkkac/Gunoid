<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" type="text/css" href="gunoid.css">
		<title>Gunoid</title>

		<!-- Wireframe triangles. -->
		<script id="wireframeVertexShader" type="x-shader/x-vertex">
			attribute vec2 position;
			// modelTransform.xy: [scaling * cos(angle), scaling * sin(angle)]
			// modelTransform.zw: translation
			attribute vec4 modelTransform;
			attribute vec4 modelColor;
			uniform mat3 projViewMatrix;
			varying vec4 color;

			void main(void) {
				vec2 scaledAndRotated = vec2(
					dot(modelTransform.xy, vec2(position.x, -position.y)),
					dot(modelTransform.xy, position.yx)
					);
				vec3 translated = vec3(scaledAndRotated + modelTransform.zw, 1.0);
				gl_Position = vec4(projViewMatrix * translated, 1.0);
				color = modelColor;
			}
		</script>
		<script id="wireframeFragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 color;

			void main(void) {
				gl_FragColor = color;
			}
		</script>

		<!-- Textured point sprites. -->
		<script id="texturedPointVertexShader" type="x-shader/x-vertex">
			attribute vec2 position;
			// modelTransform.xy: [scaling * cos(angle), scaling * sin(angle)]
			// modelTransform.zw: translation
			attribute vec4 modelTransform;
			attribute vec4 modelColor;
			uniform mat3 projViewMatrix;
			uniform vec2 viewportSize;
			varying vec4 color;

			void main(void) {
				vec2 scaledAndRotated = vec2(
					dot(modelTransform.xy, vec2(position.x, -position.y)),
					dot(modelTransform.xy, position.yx)
					);
				vec3 translated = vec3(scaledAndRotated + modelTransform.zw, 1.0);
				gl_Position = vec4(projViewMatrix * translated, 1.0);
				color = modelColor;

				// Calculate point size based on how the length of unit vector (1, 0) is changed by
				// model/view/proj transforms. gl_PointSize is in pixels so we multiply final
				// device coordinates by viewport size, then calculate length.
				gl_PointSize = length((projViewMatrix * vec3(vec2(modelTransform.y, -modelTransform.x), 0.0)).xy * viewportSize);
			}
		</script>
		<script id="texturedPointFragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 color;
			uniform sampler2D sampler;

			void main(void) {
				gl_FragColor = color * texture2D(sampler, gl_PointCoord);
			}
		</script>

		<!-- Textured point sprites without model transform. Allows texture offset/scaling.
		Uses texture luminance as alpha. -->
		<script id="textVertexShader" type="x-shader/x-vertex">
			attribute vec2 vertexPosition;
			attribute vec2 vertexSize;
			attribute vec4 vertexColor;
			attribute vec2 vertexTextureOffset;
			attribute vec2 vertexTextureSize;
			attribute vec2 vertexTextureCutoff;
			uniform mat3 projViewMatrix;
			//uniform float viewportWidth;
			varying vec4 fragColor;
			varying vec2 fragTextureOffset;
			varying vec2 fragTextureSize;
			varying vec2 fragTextureCutoff;

			void main(void) {
				gl_Position = vec4(projViewMatrix * vec3(vertexPosition, 1.0), 1.0);
				fragColor = vertexColor;
				gl_PointSize = vertexSize.y;
				fragTextureOffset = vertexTextureOffset;
				fragTextureSize = vertexTextureSize;
				fragTextureCutoff = vertexTextureCutoff;
			}
		</script>
		<script id="textFragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 fragColor;
			varying vec2 fragTextureOffset;
			varying vec2 fragTextureSize;
			varying vec2 fragTextureCutoff;
			uniform sampler2D sampler;

			void main(void) {
				if (gl_PointCoord.x >= fragTextureCutoff.x || gl_PointCoord.y >= fragTextureCutoff.y)
					discard;
				vec4 s = texture2D(sampler, fragTextureOffset + fragTextureSize * gl_PointCoord);
				gl_FragColor = fragColor * vec4(s.rgb, s.r);
			}
		</script>

		<!-- Textured triangles. -->
		<script id="texturedModelVertexShader" type="x-shader/x-vertex">
			attribute vec2 position;
			attribute vec2 texCoords;
			// modelTransform.xy: [scaling * cos(angle), scaling * sin(angle)]
			// modelTransform.zw: translation
			attribute vec4 modelTransform;
			attribute vec4 modelColor;
			uniform mat3 projViewMatrix;
			varying vec4 color;
			varying vec2 fragTexCoords;

			void main(void) {
				vec2 scaledAndRotated = vec2(
					dot(modelTransform.xy, vec2(position.x, -position.y)),
					dot(modelTransform.xy, position.yx)
					);
				vec3 translated = vec3(scaledAndRotated + modelTransform.zw, 1.0);
				gl_Position = vec4(projViewMatrix * translated, 1.0);
				color = modelColor;
				fragTexCoords = texCoords;
			}
		</script>
		<script id="texturedModelFragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 color;
			varying vec2 fragTexCoords;
			uniform sampler2D sampler;

			void main(void) {
				gl_FragColor = color * texture2D(sampler, fragTexCoords);
			}
		</script>

		<script>
			var Module = { TOTAL_MEMORY: 20 * (1 << 20) };
		</script>
		<script src="dependencies/bpgdec8.js"></script>
		<script src="vec2d.js" type="text/javascript"></script>
		<script src="util.js" type="text/javascript"></script>
		<script src="modeldata.js" type="text/javascript"></script>
		<script src="models.js" type="text/javascript"></script>
		<script src="input.js" type="text/javascript"></script>
		<script src="fonts.js" type="text/javascript"></script>
		<script src="entity.js" type="text/javascript"></script>
		<script src="enemies.js" type="text/javascript"></script>
		<script src="projectiles.js" type="text/javascript"></script>
		<script src="weapons.js" type="text/javascript"></script>
		<script src="loot.js" type="text/javascript"></script>
		<script src="player.js" type="text/javascript"></script>
		<script src="spawner.js" type="text/javascript"></script>
		<script src="gunoid.js" type="text/javascript"></script>
	</head>
	<body onload="game.start()">
		<canvas id="webglcanvas" width="800" height="600" moz-opaque></canvas>
	</body>
</html>
